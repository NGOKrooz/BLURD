/**
 * Circom/SnarkJS Verifier Integration
 * 
 * Uses SnarkJS to verify zero-knowledge proofs generated by Circom circuits
 * Circuit: age18.circom - verifies age >= min_age without revealing actual age
 */

let snarkjs: any = null;
let isInitialized = false;

/**
 * Initialize SnarkJS library
 */
export async function initCircomVerifier(): Promise<void> {
  if (isInitialized) {
    return;
  }

  try {
    snarkjs = await import('snarkjs');
    isInitialized = true;
    console.log('âœ… SnarkJS verifier initialized successfully');
  } catch (error) {
    console.error('SnarkJS not available:', error);
    throw new Error('SnarkJS library not found. Please install: npm install snarkjs');
  }
}

/**
 * Verify a zero-knowledge proof
 * 
 * @param proof - The proof JSON object (GroTH16 format)
 * @param publicInputs - Array of public inputs (should contain result)
 * @returns true if proof is valid, false otherwise
 */
export async function verifyProof(
  proof: any,
  publicInputs: string[]
): Promise<{
  valid: boolean;
  error?: string;
}> {
  if (!isInitialized || !snarkjs) {
    await initCircomVerifier();
  }

  try {
    // Load verification key
    const verifierKeyPath = '/zk/age18_verification_key.json';
    const verifierKeyResponse = await fetch(verifierKeyPath);
    if (!verifierKeyResponse.ok) {
      return {
        valid: false,
        error: `Verification key not found at ${verifierKeyPath}`,
      };
    }
    const verifierKey = await verifierKeyResponse.json();

    // Convert public inputs from strings to BigInt if needed
    const publicSignals = publicInputs.map((s: string | number) => {
      if (typeof s === 'string') {
        return BigInt(s);
      }
      return BigInt(s);
    });

    // Verify the proof using SnarkJS
    const isValid = await snarkjs.groth16.verify(
      verifierKey,
      publicSignals,
      proof
    );

    return {
      valid: isValid,
    };
  } catch (error: any) {
    console.error('Proof verification error:', error);
    return {
      valid: false,
      error: error.message || 'Verification failed',
    };
  }
}

/**
 * Validate proof structure
 */
export function validateProofStructure(proof: any): {
  valid: boolean;
  error?: string;
} {
  if (!proof) {
    return { valid: false, error: 'Proof is required' };
  }

  if (typeof proof !== 'object') {
    return { valid: false, error: 'Proof must be a JSON object' };
  }

  // Check for Groth16 proof structure
  if (!proof.pi_a || !proof.pi_b || !proof.pi_c) {
    return { valid: false, error: 'Invalid proof structure. Missing pi_a, pi_b, or pi_c' };
  }

  return { valid: true };
}

/**
 * Validate public inputs structure
 */
export function validatePublicInputs(publicInputs: any): {
  valid: boolean;
  error?: string;
} {
  if (!publicInputs) {
    return { valid: false, error: 'Public inputs are required' };
  }

  if (!Array.isArray(publicInputs)) {
    return { valid: false, error: 'Public inputs must be an array' };
  }

  if (publicInputs.length === 0) {
    return { valid: false, error: 'Public inputs cannot be empty' };
  }

  return { valid: true };
}

